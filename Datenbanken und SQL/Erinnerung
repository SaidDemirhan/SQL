Erinnerung

DDL : Data Definition Language(Veri  Tanimlama Dili

Create: veri tabaninda nesne olusturur
Alter: Veri tabaninin yapisini degistirir.
Drop:  Veri tabanindan obje siler
Truncate: Tablodaki kayitlari icerdikleri alanla birlikte siler
Comment: yorum ekler
Rename: Nesnenin adini degistirir.

------------------------------------------------------
DML : Data Manipulation Language (Veri Düzenleme Dili)

select: veri tabanindan kayit okur
insert: tabloya kayit ekler
update: tablodaki kaydi günceller
delete: tablodaki kayitlari siler ancak kapladigi alan kalir
merge, upsert: ekleme veya güncelleme yapar

------------------------------------------------------
DCL : Data Control Language (veri kontrol dili)

grant: kullaniciya veri tabanina erisim yetkisi verir
deny: Kullanicilarin haklarini kisitlar
revoke: grant ile verilen yetkiyi geri alir

------------------------------------------------------
TCL : Transaction Control Language( islem kontrol dili)

commit: yapilanlari kalici hale getirir, isin tamamlanmasini saglar
savepoint: daha sonra geri dönülebilecek bir dönüs noktasi belirler.
rollback: son commit e kadar olan yeri geri alir.

------------------------------------------------------

YORUM SATIRI (--)

-- isaretini satir basina koymamiz yeterlidir.

------------------------------------------------------

query builder penceresi sistemde olusturulan tablolari grafiksel olarak listeler.(oracle)

------------------------------------------------------
Sorgulama: (SELECT)

SELECT (kolon_adi) FROM (tablo_adi);
   kolon adi yerine * isareti koyarak tüm tabloyu da listeleyebiliriz.

-------------------------------------------------------
Sorgulanan verilerin büyük/kücük harf seklinde listeleme: (LOWER/UPPER/INITCAP)

SELECT LOWER (adi), UPPER(soyadi) FROM personel;

INITCAP kelimelerin yalnizca ilk harflerini büyük yapar.
-------------------------------------------------------
Filtreleme: (WHERE)

SELECT (kolon_adi) FROM (tablo_adi) WHERE (sartimiz)
   WHERE diploma_notu>=70 AND cinsiyet= "E"


-------------------------------------------------------
Listedeki sütün adini istedigimiz gibi görüntüleme: (AS veya tirnak isreti vaya direkt yazma) 

SELECT name AS isim  FROM (tablo_adi)  (tavsiye edilir)
SELECT name "isim"  FROM (tablo_adi)
SELECT name isim  FROM (tablo_adi)

------------------------------------------------------
Tekrar eden verilerin tekrarini önleme (DISTINCT)

SELECT DISTINCT (kolon_adi) FROM (tablo_adi);

-----------------------------------------------------
Iki kolonu birlestirerek listeleme: ( ||' '||)

SELECT isim ||' '|| soyisim FROM personel;

   istersek arasina bosluk yerine istenilen ifade de yazilabilir.
   iki sütun arasindaki VIRGÜL yerine yazilmalidir.

-----------------------------------------------------
INT deger degisikligi icin matematiksel islemler kullanilarnilir.

SELECT ad, soyad, maas*2 AS YeniYilMaasi FROM personel

-----------------------------------------------------
Isimlendirmelerde özel kelimelerin kullanilmamasi gerekir.
Büyük veya kücük harf olmasi önemli degildir.

#######################################################

TABLO OLUSTURMA (CREATE TABLE)

CREATE TABLE personel
(adi varchar2(20),
soyadi varchar(15),
telefon_numarasi number(15)
);

------------------------------------------------------
varchar: string olarak isimlendirilir, deger mutlaka tirnak icinde girilmelidir.
number: Int deger girmeek icin kullanilir.
------------------------------------------------------

Tabloya veri girisi yapma: (INSERT INTO)

INSERT INTO personel (adi, soyadi, telefon_numarasi) 
VALUES ("Ahmet", "Delice", 05362856598); 

veya veriler sirasiyla girilmek sartiyla:

INSERT INTO personel VALUES ("Mehmet", "Akillica", 05432659875);

----------------------------------------------------------

Tabloya yeni bir sütun ekleme: (ALTER TABLE tablo_adi ADD kolon_adi varchar(10));)

ALTER TABLE personel 
ADD 
email varchar(20));

--------------------------------------------------------

Tabloyu güncelleme; (MODIFY) -(UPDATE -SET)

ALTER TABLE personel
MODIFY
email varchar(25);

   email alaninin 20 karakterden 25 karaktere cikartmis olduk.

UPDATE personel SET isim ='Abdurrahman'
WHERE soyisim='Delice';

   Eger yerini belirtmezsek tüm isimleri 'Abdurrahman' yapacaktir!
-------------------------------------------------------
SILME

Tabloyu silme: (DROP)

DROP TABLE personel;

Tablodan sütun silme: (DROP)

ALTER TABLE personel DROP COLUMN email;

-------------------------------------------------------
Sütunu kullanim disi birakma: (SET UNUSED COLUMN)

ALTER TABLE personel SET UNUSED COLUMN telefon_numarasi;

------------------------------------------------------
Veri silme: (DELETE)

DELETE FROM personel WHERE isim='Abdurrahman';

   veya WHERE telefon_numarasi=05432659875;

   tablo  kalir secece veriler silinir!

****TRUNCATE : Delete ile aynidir, geri dönüsü yoktur.
  WHERE ile birlikte kullanilamaz.
    TRUNCATE TABLE personel;
    
### ROLLBACK ile geri dönüm noktasi olustur.
  ROLLBACK SELECT * FROM personel;
-------------------------------------------------------
Karsilastirma Operatörleri

= esittir
      SELECT ad,soyad FROM personel WHERE maas=2000;
< kücüktür
> büyüktür
>= büyük esit
<= kücük esit
<> esit degil
BETWEEN ... AND ... =  arasinda
      SELECT ad, soyad FROM personel WHERE maas BETWEEN  1000 AND 1500;
        sayi olabilecegi gibi string degerler de olabilir.(tirnak i unutma)
         SELECT ad, soyad FROM personel WHERE soyad BETWEEN 'Akillica AND 'Delice';
IN icinde bulunmasi gereken degerler (50,60,70)
      SELECT ad, soyad FROM personel WHERE maas IN (1000, 1500, 2000, 2500);
LIKE karakter arama
      SELECT isim FROM personel WHERE soyisim LIKE 'K%';
         Soyadi k ile baslayanlarin isimlerini listelettirdik. int degerler de talep edilebilir.
       SELECT isim, soyisim FROM personel WHERE soyisim LIKE '_a%';   
         soyadinin ikinci karakteri a olanlarin adini ve soyadini getirir.
IS NULL null degerlerini döndürür.
      SELECT ad, soyad FROM personel WHERE email IS NULL;
         e mail adresi bulunmayanlari getirir.
IS NOT NULL null olmayan degerleri getirir.
      SELECT ad, soyad FROM personel WHERE email IS NOT NULL;
-------------------------------------------------------

Mantiksal OPeratörler

AND iki sartin birlikte olmasini ister
OR iki sarttaan bir tanesinin olmasi yeterlidir.
NOT degil olanlari getirir.

--------------------------------------------------------
Siralama komutlari (ORDER BY)

ASC : komutu default olarak gelir, yazmasak da bu sekilde siralayacaktir.
   Kücükten büyüge dogru siralar
   birden fazla sütun olarak siralama yapilabilir.
   
DESC : Büyükten kücüge siralam komututdur.

   SELECT ad, soyad, email FROM personel ORDER BY soyad DESC;
      Soyadlarin z den a ya dogru siralarandigini görürürz.
      
   SELECT ad, soyad, email FROM personel ORDER BY 3;   
      3. sütünda ne varsa ona göre siralama yapilir.

----------------------------------------------------------
Gruplandirma komutlari (GROUP BY)

GROUP BY : sorgularimizi belirli bir alana göre gruplandirir.

HAVING : WHERE ile ayni görevi yapar, HAVING; GROUP BY yapisi icinde kullanilmalidir.

   SELECT  soyad, MAX(maas) FROM personel
   GROUP BY soyad
   HAVING MAX(maas)>2000;

----------------------------------------------------------
AMPERSAND (&)

Program üzerinden databank taki istenilen bilginin bir degerini girerek bilgilerini getirmek icin kullanilir.

SELECT ogrenci_no, ad, soyad, email FROM ögrenciler WHERE ögrenci_no= &Ögrenci_numasari_girirniz;

----------------------------------------------------------
Double Ampersand (&&)

Bizden yeniden deger girmemmiz istenmeden son kaydi getirmeyi saglar.

   SELECT ad, soyad, &&ogrenci_no FROM ogrenciler ORDER BY &ogrenci_no;
   
---------------------------------------------------------
DEFINE ve &

Kullanicidan deger almadan direkt deger verip sorguyu calistirmamizi saglar.

   DEFINE ogrenci_no=20 
   SELECT ad, soyad, email FROM ogrenciler 
   WHERE ogrenci_numarasi=&ogrenci_no;
   
define yi kaldirmak icin UNDEFINED yazilip deger verilmeden atandigi yer ile birlikte calistirlmasi gerekir.   

   UNDEFINE ogrenci_no; ....
   
---------------------------------------------------------   

Character Manipulation

CONCAT sütundaki degerleri birlestirir.
LENGTH karakter sayisini getirir.
INSTR sorgulanan karakterin kacinci sirada oldugunu getirir.
SUBSTR sondan zb. 4 kaarakter istenilen karakterlerle bitiyor mu..

   SELECT ogrenci_no, CONCAT(ad,soyad) AS kimlik, LENGTH (soyad) AS soyad_uzunlugu, INSTR(soyad, 'e') AS soyaddaki_e_sirasi
   FROM ogrenciler WHERE SUBSTR (email,10)='@gmail.com';
      Email adresi gmail olanlarin soyad uzunlugu ve soyadinda e harfinin sirasi tespit ediliyor.
  
RPAD 
   '*' belli bir length e tamamlanmasi gerekiyorsa kullanilir

   SELECT ogrenci_no, RPAD (ogrenci_no,3,'*') FROM  ogrenciler;
      eger 3 basamaklidan dah kücük bir ögrenci numarasi varsa arkasina * veya istenilen bir karakter eklenir.
      
LPAD
   ise soluna istenilen isareti koymaya yarar.
   
REPLACE
   bir kalimeyi baska bir kelime ile degistirmeye yarar.
   SELECT REPLACE ('oracle egitimi', 'oracle', 'SQL') FROM dual;
      yani SQL egitimi sekline döner.
      
      *** dual demek sanal bir tablo olusturmak demektir.  
      
TRIM
    bas ve sonundaki istenilmeyen karakterleri hesaba katmayarak length ini getirdi.
    SELECT LENGT (TRIM(' ' FROM ' Ahmet')) FROM dual;
      uzunlugu normalde 6 iken bosluklari cikartip 5 verecektir.
      
    SELECT TRIM (BOTH '2' FROM '232AHMET22')FROM dual;          //32AHMET
      bas ve sonundaki istenilmeyenler silindi.
      
    SELECT TRIM(TRAILING '5' FROM '555Sari555') FROM dual;       //555Sari
      yalnizca sonundaki istenilmeyenler gitti.
    
    SELECT TRIM(LEADING '5' FROM '555Sari555') FROM dual;         //Sari555
      
 -------------------------------------------------------------------
 
 NUMBER FONKSIYONLARI
 
 ROUND
  yakin oldugu yere dogru yuvarlar, virgülden sonraki kismin kac basamak olmasini istersek onu yazariz.
  sifirlar yazilmaz.
  SELELCT ROUND (45.923,2)FROM dual;      //45,92
  SELELCT ROUND (45.923,6)FROM dual;      //45,923
  
 TRUNC 
  istisnasiz asagi degere yuvarlar
  SELECT TRUNC (56.986,2) FROM dual       //56,98
      
 MOD
  kalan degerleri yazdirir.
  SELECT ad, soyad, maas,MOD (maas,1200) FROM personel WHERE maas>1200;
   alinan maasi 1200 e bölerek  kalani yazdirir.
      
-------------------------------------------------------------------------   
TARRIHLER
   SELECT SYSDATE FROM dual;
   tarihi getirir.
   
   SELECT ad, soyad, (SYSDATE-kayit_tarihi)/7 AS calisilan_hafta  FROM personel WHERE isciler; 
      iscilerin kac haftadir ista calistiklarini getirdi.
      
   SELECT ADD_MONTHS (SYSDATE,6)FROM dual;
      6 ay sonraki tarihi verir.
   
   SELECT NEXT_DAY(SYSDATE, 'SAMSTAG') FROM dual;
      bir sonraki cumartesi gününün tarihini getirir.
      
   SELECT LAST_DAY(SYSDATE) FROM dual;
      bulunulan ayin son gününü verir.
      
   SELECT ROUND (SYSDATE 'MONTH') FROM dual;
      eger ayin 15 inden once ise bulunulan ayin 1 ine yoksa bir sonraki ayin 1 ine yuvarlar
      
   SELECT ROUND (SYSDATE 'YEAR') FROM dual;   
      Haziran oncesi ise bulunulan yilin 1 ocak ina yoka bir sonraki yila yuvarlar.
         eger yuvarlanmasin denirse TRUNC da kullanilabilir.
      
   SELECT ad, soyad, kayit_tarihi, TO_CHAR(kayit_tarihi,'fmDD Month YYYY') AS tarih FROM personel;
      to_char fonksiyonuyla bilgisayar dili ile 13 Ocak 2001 gibi bir tarih atilir.
   
   SELECT ad, soyad kayit_tarihi FROM personel WHERE kayit_tarihi< TO_DATE ('01/01/1997','DD/MM/RR');
      to_date ile eger tarihlerini bilmedigimiz bir liste varsa bu sekilde anlasilir dile cevirtebilirirz.
   
---------------------------------------------------------------------------

Dönüsüm Fonksiyonlari

NVL NVL2

istenilmeyen bir degeri cikarma isine yarar
örnegin eger null degerlere ile satirlarla islem yapilirsa bu islemlerin sonucu da null oluyor, bunu engellemek icin bu komut mevcut.

NULLIF 

Eger iki deger ayni ise null yazdirma fonksiyonudur.

COALESCE

Eger iki deger de null ise istenilen notun yazilmasini saglar.

CASE 

WHEN THEN ve ELSE ile kulanilir

--------------------------------------------------------------------

Grup fonksiyon türleri

AVG - ortalama islemi
   SELECT AVG(yilsonu_notu) FROM tablo
   WHERE ...
      Eger yil sonu notu 0 olan varsa bunu cikartmak icin NVL fonksiyonu kullanilir.
      SELECT AVG(NVL(ogrenci_notu,0)) FROM ogrenciler
   

COUNT - deger veya sayi
   SELECT COUNT(*) FROM ogrenciler
   WHERE ogrenci_notu=50;
      notu 50 olan kac ogrenci varsa onu sadece sayi olarak getirecektir.
      
   SELECT COUNT(DISTINCT ogrenci_notu) FROM ogrenciler;
      tekrarlamayan ögrenci notu sayisini getirir.

MAX ve MIN - en yüksek ve düsük degerleri döndürür.
   SELECT MAX(maas) FROM personel;

STDDEV - Standart hatalarin tespitini yapar

SUM - toplami verir.
   SELECT SUM(maas) FROM personel;
   
VARIANCE - varyansi verir

****** birkac fonksiyon bir arada kullanilabilir.

** WHERE ifadesi ie bu komutlar kullanilmaz, HAVING ile kullanilir.

-------------------------------------------------

JOIN


iki ya da daha fazla tabloyu ayni anda sorgulayip sonuc tablosu olusturmak icin kullaniriz.

CROSS JOIN
   iliskili olsun veya olmasin tüm satirlari gösterir.
   SELECT kolon_adi FROM tabloA CROSS JOIN tabloB 
   
INNER JOIN
   kesisim alanini listeler.
   SELECT kolon_adi FROM tabloA INNER JOIN tabloB ON tabloA.soyadi=tabloB.soyadi
   
LEFT JOIN   
   ilk tabloda olanlari getirir. kesisenleri zaten ilk tabloda da olacaktir sadece 2. tabloya özel olanlari göremeyiz.
   SELECT kolon_adi FROM tabloA LEFT JOIN tabloB ON tabloA.soyadi=tabloB.soyadi

   eger yalnizca Ada olanlari isteseydik;
   SELECT kolon_adi FROM tabloA LEFT JOIN tabloB ON tabloA.soyadi=tabloB.soyadi WHERE tabloB.soyadi is Null
   
RIGHT JOIN
   ikinci tabloda olanlari getirir. KESISIM dahil!
   SELECT kolon_adi FROM tabloA RIGHT JOIN tabloB ON tabloA.soyadi=tabloB.soyadi

   eger kesisim istenmeseydi
   SELECT kolon_adi FROM tabloA RIGHT JOIN tabloB ON tabloA.soyadi=tabloB.soyadi WHERE tabloA.soyadi is Null

   Eger kesisim noktasini degil de sadece ilk tabloda ve sadece 2. tabloda olanlari isteseydik;
   SELECT kolon_adi FROM tabloA RIGHT JOIN tabloB ON tabloA.soyadi=tabloB.soyadi WHERE (tabloA.soyadi is Null) OR (tabloB.soyadi is Null)
   
FULL JOIN
   ilk tabloda ve ikinci tabloda olan verileri tekrarlamadan getirir.
   SELECT kolon_adi FROM tabloA FULL JOIN tabloB ON tabloA.soyadi=tabloB.soyadi
   
   **** full outer joiin, right outer join, left outer join seklinde kullanimi yaygin.
   inner joini de sadece JOIN olarak da kullanana var
   
   ### eger uzun uzun tablo ismi yazilmak istenmiyorsa;
    SELECT kolon_adi FROM tabloA a RIGHT JOIN tabloB b ON a.soyadi=b.soyadi 
    
---------------------------------------------------------------

Ic ice SELECT

SELECT adi, soyadi, maas FROM personel
WHERE maas >
(SELECT maas FROM personel
WHERE adi='Deniz');
   adi Deniz olan kisinin maasindan daha yüksek maas alanlari getirir.
   
ANY : olumsuzluk kelimesidir   
  .... WHERE maas > ANY (SELECT .... seklinde yazilir 
  
ALL : ayni ANY gibi kullanilir ve istenilenlerin hepsini getirir.  

IN de kullanilir.

---------------------------------------------------------------

desc tablo_adi

yazarak tablodaki deger ve ayrintilarini rahatca görebiliriz.

--------------------------------------------------------------

SET Operatörleri

INTERSECT :kesisimini ifade eder
UNION - UNION ALL : hepsini ifade eder.
  SELECT soyad FROM ogrenciler
  UNION
  SELECT soyad FROM personel
MINUS : Kesisimde olmayan ama sadece ilk listede olani verir.

39. video
